<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Virtual Tour</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #container { position: absolute; top: 0; left: 0; width: 100%; height: 100vh; }
    </style>
</head>
<body>
    <div id="container"></div>

    <script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.121.0/build/three.module.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.121.0/examples/jsm/controls/OrbitControls.js';
import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.121.0/examples/jsm/webxr/VRButton.js';
import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.121.0/examples/jsm/webxr/XRControllerModelFactory.js';
import TWEEN from 'https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.esm.js';

// Escena, cámara y renderizador
const container = document.getElementById('container');
const scenes = [];
for (let i = 0; i < 11; i++) {
    scenes.push(new THREE.Scene());
}

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
container.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));

// Controles
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableZoom = false;
controls.enablePan = false;
camera.position.set(0, 0, 0.1);

// Cargar texturas equirectangulares
const textureLoader = new THREE.TextureLoader();
const texturePaths = [
    'images/centrocaldas.jpg', 'images/catedral.jpg', 'images/bancolombia.jpg',
    'images/bancobogota.jpg', 'images/juanvaldez.jpg', 'images/catt.jpg',
    'images/reloj.jpg', 'images/esq-b.jpg', 'images/esq-bb.jpg',
    'images/esq-c.jpg', 'images/humilladero1.jpg'
];
const textures = new Array(texturePaths.length);

let texturesLoaded = 0;

texturePaths.forEach((path, index) => {
    textureLoader.load(path, (texture) => {
        textures[index] = texture;
        texturesLoaded++;
        if (texturesLoaded === texturePaths.length) {
            init();
        }
    });
});

function init() {
    // Crear esferas para cada escena
    const geometry = new THREE.SphereGeometry(500, 60, 40);
    geometry.scale(-1, 1, 1); // Invertir la esfera para mirar hacia dentro

    textures.forEach((texture, index) => {
        const material = new THREE.MeshBasicMaterial({ map: texture });
        const sphere = new THREE.Mesh(geometry, material);
        scenes[index].add(sphere);
    });

    // Establecer la escena inicial
    let currentScene = scenes[0];
    renderer.render(currentScene, camera);

    // Función para cambiar de escena con transición de zoom-in
    function changeScene(scene) {
        new TWEEN.Tween(camera.position)
            .to({ x: 0, y: 0, z: 0.01 }, 500)
            .easing(TWEEN.Easing.Quadratic.Out)
            .onComplete(() => {
                currentScene = scene;
                new TWEEN.Tween(camera.position)
                    .to({ x: 0, y: 0, z: 0.1 }, 500)
                    .easing(TWEEN.Easing.Quadratic.In)
                    .start();
            })
            .start();
    }

    // Crear las flechas de navegación
    const arrowTexture = textureLoader.load('images/next.png');

    function createArrow(position, targetScene) {
        const spriteMaterial = new THREE.SpriteMaterial({ map: arrowTexture });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.position.copy(position);
        sprite.scale.set(20, 20, 1);
        sprite.userData = { targetScene };
        sprite.material.depthTest = false; // Para evitar la deformación
        sprite.material.depthWrite = false;
        return sprite;
    }

    // Enlazar escenas con flechas
    scenes[0].add(createArrow(new THREE.Vector3(32, -130, 480), scenes[1]));
    scenes[0].add(createArrow(new THREE.Vector3(484, -120, -16), scenes[2]));
    scenes[0].add(createArrow(new THREE.Vector3(-3, -150, -480), scenes[3]));
    scenes[0].add(createArrow(new THREE.Vector3(-477, -65, 130), scenes[4]));

    scenes[1].add(createArrow(new THREE.Vector3(453, -135, -157), scenes[0]));
    scenes[1].add(createArrow(new THREE.Vector3(185, -94, 453), scenes[9]));
    scenes[1].add(createArrow(new THREE.Vector3(-142, -91, -470), scenes[6]));
    scenes[1].add(createArrow(new THREE.Vector3(-462, -76, 171), scenes[5]));

    scenes[2].add(createArrow(new THREE.Vector3(-443, -150, 173), scenes[0]));
    scenes[2].add(createArrow(new THREE.Vector3(144, -122, 462), scenes[9]));
    scenes[2].add(createArrow(new THREE.Vector3(-111, -85, -479), scenes[8]));

    scenes[3].add(createArrow(new THREE.Vector3(-465, -141, 113), scenes[0]));
    scenes[3].add(createArrow(new THREE.Vector3(75, -124, 477), scenes[8]));
    scenes[3].add(createArrow(new THREE.Vector3(-137, -109, -467), scenes[7]));

    scenes[4].add(createArrow(new THREE.Vector3(-480, -130, -24), scenes[0]));
    scenes[4].add(createArrow(new THREE.Vector3(-20, -105, -487), scenes[6]));
    scenes[4].add(createArrow(new THREE.Vector3(-68, -100, 484), scenes[7]));

    scenes[5].add(createArrow(new THREE.Vector3(469, -161, 56), scenes[1]));

    scenes[6].add(createArrow(new THREE.Vector3(-305, -114, -377), scenes[1]));
    scenes[6].add(createArrow(new THREE.Vector3(-244, -126, 416), scenes[4]));

    scenes[7].add(createArrow(new THREE.Vector3(-255, -82, 421), scenes[3]));
    scenes[7].add(createArrow(new THREE.Vector3(-388, -87, -301), scenes[4]));

    scenes[8].add(createArrow(new THREE.Vector3(-273, -97, 405), scenes[2]));
    scenes[8].add(createArrow(new THREE.Vector3(-385, -78, -307), scenes[3]));
    scenes[8].add(createArrow(new THREE.Vector3(431, -112, -223), scenes[10]));

    scenes[9].add(createArrow(new THREE.Vector3(-91, -125, 474), scenes[1]));
    scenes[9].add(createArrow(new THREE.Vector3(-421, -96, -250), scenes[2]));

    scenes[10].add(createArrow(new THREE.Vector3(88, -145, 469), scenes[2]));

    // Raycaster para detectar clics en las flechas
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onMouseClick(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObjects(currentScene.children, true);
        if (intersects.length > 0) {
            const intersectedObject = intersects[0].object;
            if (intersectedObject.userData.targetScene) {
                changeScene(intersectedObject.userData.targetScene);
            }
        }
    }

    window.addEventListener('click', onMouseClick, false);

    // Controladores de VR
    const controllerModelFactory = new XRControllerModelFactory();

    const controller1 = renderer.xr.getController(0);
    controller1.addEventListener('selectstart', onSelectStart);
    controller1.addEventListener('selectend', onSelectEnd);
    scenes[0].add(controller1);

    const controller2 = renderer.xr.getController(1);
    controller2.addEventListener('selectstart', onSelectStart);
    controller2.addEventListener('selectend', onSelectEnd);
    scenes[0].add(controller2);

    const controllerGrip1 = renderer.xr.getControllerGrip(0);
    controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
    scenes[0].add(controllerGrip1);

    const controllerGrip2 = renderer.xr.getControllerGrip(1);
    controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
    scenes[0].add(controllerGrip2);

    // Crear rayos para los controladores
    const geometry1 = new THREE.BufferGeometry();
    geometry1.setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -5)]);
    
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });

    const line1 = new THREE.Line(geometry1, lineMaterial);
    controller1.add(line1);

    const line2 = new THREE.Line(geometry1, lineMaterial);
    controller2.add(line2);

    function onSelectStart(event) {
        const controller = event.target;
        const intersections = getIntersections(controller);
        if (intersections.length > 0) {
            const intersection = intersections[0];
            const object = intersection.object;
            if (object.userData.targetScene) {
                changeScene(object.userData.targetScene);
            }
        }
    }

    function onSelectEnd(event) {
        // Aquí puedes agregar lógica adicional para cuando termine la selección
    }

    function getIntersections(controller) {
        const tempMatrix = new THREE.Matrix4();
        tempMatrix.identity().extractRotation(controller.matrixWorld);
        raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
        raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
        return raycaster.intersectObjects(currentScene.children, true);
    }

    // Animación
    function animate() {
        controls.update();
        TWEEN.update();
        renderer.render(currentScene, camera);
    }
    renderer.setAnimationLoop(animate);

    // Ajustar la ventana
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

    </script>
</body>
</html>
