<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>TurismoCauca3.0</title>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
            }
        }
    </script>

</head>
<body>

    <div class="button-container">
        <a href="index.html" class="image-button">
            <img src="textures/home.png" alt="Button Image">
        </a>
    </div>

    <nav>
        <div class="ham-menu">
            <span></span>
            <span></span>
            <span></span>
        </div>
    </nav>

    <div class="off-screen-menu">
        <ul>
            <li><a href="#" id="vr-btn"><img src="textures/VR.png" alt="VR"></a></li>
            <li>
                <a href="#" id="mute-btn">
                    <img id="mute-icon" class="normal" src="textures/muted.png" data-original-src="textures/muted.png" data-alt-src="textures/unmuted.png" alt="Mute" />
                </a>
            </li>
            <li><a href="#" id="expand-btn"><img class="normal" src="textures/fullscreen.png" data-original-src="textures/fullscreen.png" data-alt-src="textures/reducescreen.png" alt="Fullscreen"></a></li>
            <li><a href="#" class="share-x"><img src="textures/x.png" alt="Close"></a></li>
            <li><a href="#" class="share-facebook"><img src="textures/f.png" alt="Facebook"></a></li>
        </ul>
    </div>

    <div class="card-container">
        <div class="card" data-environment="0">
            <img src="images/centrocaldas.jpg" alt="Centro Caldas">
            <div class="card-title">Centro Caldas</div>
        </div>
        <div class="card" data-environment="1">
            <img src="images/catedral.jpg" alt="Catedral">
            <div class="card-title">Catedral</div>
        </div>
        <div class="card" data-environment="2">
            <img src="images/bancolombia.jpg" alt="Bancolombia">
            <div class="card-title">Bancolombia</div>
        </div>
        <div class="card" data-environment="3">
            <img src="images/bancobogota.jpg" alt="Banco de Bogotá">
            <div class="card-title">Banco de Bogotá</div>
        </div>
    </div>

    <script src="menu.js"></script> 

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let camera, scene, renderer, controls;
        let environments = [];
        let sprites = [];
        let currentEnvironmentIndex = 0;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        init();
        animate();

        function init() {
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100);
            camera.position.set(0, 0, 0.1);
            scene = new THREE.Scene();
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.12;
            controls.enableZoom = true;
            controls.zoomSpeed = 0.3;
            controls.enablePan = false;
            controls.rotateSpeed = -0.3;

            const textureLoader = new THREE.TextureLoader();
            const environmentImages = [
                'images/centrocaldas.jpg',
                'images/catedral.jpg',
                'images/bancolombia.jpg',
                'images/bancobogota.jpg',
                'images/juanvaldez.jpg',
                'images/catt.jpg'
            ];

            for (let i = 0; i < environmentImages.length; i++) {
                const geometry = new THREE.SphereGeometry(500, 60, 40);
                geometry.scale(-1, 1, 1);

                const texture = textureLoader.load(environmentImages[i]);
                texture.colorSpace = THREE.SRGBColorSpace;
                const material = new THREE.MeshBasicMaterial({ map: texture });

                const mesh = new THREE.Mesh(geometry, material);
                environments.push(mesh);
            }

            scene.add(environments[currentEnvironmentIndex]);

            const spriteData = [
                {
                    positions: [
                        { x: 10, y: -25, z: 100 },
                        { x: 100, y: -30, z: -5 },
                        { x: -5, y: -27, z: -90 },
                        { x: -100, y: -10, z: 27 }
                    ],
                    destinations: [1, 2, 3, 4]
                },
                {
                    positions: [
                        { x: 100, y: -30, z: -35 },
                        { x: 42, y: -25, z: 100 },
                        { x: -25, y: -25, z: -90 },
                        { x: -80, y: -15, z: 28 }
                    ],
                    destinations: [0, 2, 4, 5]
                },
                {
                    positions: [
                        { x: -90, y: -32, z: 35 },
                        { x: 25, y: -25, z: 100 },
                        { x: -27, y: -27, z: -100 }
                    ],
                    destinations: [0, 1, 3]
                },
                {
                    positions: [
                        { x: -80, y: -25, z: 20 },
                        { x: 10, y: -25, z: 90 },
                        { x: -30, y: -27, z: -90 }
                    ],
                    destinations: [0, 2, 4]
                },
                {
                    positions: [
                        { x: -90, y: -22, z: -5 },
                        { x: -5, y: -27, z: -80 },
                        { x: -15, y: -35, z: 90 }
                    ],
                    destinations: [0, 1, 3]
                },
                {
                    positions: [
                        { x: 100, y: -35, z: 12 }
                    ],
                    destinations: [1]
                }
            ];

            const spriteImage = 'images/next.png';
            const spriteMaterial = new THREE.SpriteMaterial({ map: textureLoader.load(spriteImage) });

            for (let i = 0; i < spriteData.length; i++) {
                const spritesInEnvironment = [];
                for (let j = 0; j < spriteData[i].positions.length; j++) {
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.position.set(spriteData[i].positions[j].x, spriteData[i].positions[j].y, spriteData[i].positions[j].z);
                    sprite.scale.set(8, 8, 1);
                    sprite.name = `env${i}-sprite${j}`;
                    sprite.userData.destination = spriteData[i].destinations[j];

                    spritesInEnvironment.push(sprite);
                }
                sprites.push(spritesInEnvironment);
            }

            sprites[currentEnvironmentIndex].forEach(sprite => scene.add(sprite));

            document.addEventListener('click', onDocumentMouseDown, false);
            document.addEventListener('mousemove', onDocumentMouseMove, false);

            // Add event listeners to cards for changing environments
            const cards = document.querySelectorAll('.card');
            cards.forEach(card => {
                card.addEventListener('click', (event) => {
                    const targetSceneIndex = parseInt(event.currentTarget.getAttribute('data-environment'));
                    changeEnvironment(targetSceneIndex);
                });
            });
        }

        function onDocumentMouseDown(event) {
            event.preventDefault();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(sprites[currentEnvironmentIndex]);

            if (intersects.length > 0) {
                const intersected = intersects[0].object;
                const destinationIndex = intersected.userData.destination;

                changeEnvironment(destinationIndex);
            }
        }

        function onDocumentMouseMove(event) {
            event.preventDefault();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(sprites[currentEnvironmentIndex]);

            if (intersects.length > 0) {
                document.body.classList.add('hand-cursor');
                const intersected = intersects[0].object;
                intersected.scale.set(10, 10, 1);
            } else {
                document.body.classList.remove('hand-cursor');
                sprites[currentEnvironmentIndex].forEach(sprite => sprite.scale.set(8, 8, 1));
            }
        }

        function changeEnvironment(destinationIndex) {
            // Remove current environment and its sprites
            if (scene.children.includes(environments[currentEnvironmentIndex])) {
                scene.remove(environments[currentEnvironmentIndex]);
                sprites[currentEnvironmentIndex].forEach(sprite => scene.remove(sprite));
            }

            // Update current environment index
            currentEnvironmentIndex = destinationIndex;

            // Add new environment and its sprites
            scene.add(environments[currentEnvironmentIndex]);
            sprites[currentEnvironmentIndex].forEach(sprite => scene.add(sprite));
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        const MIN_ZOOM = 1;
        const MAX_ZOOM = 3;

        function onDocumentMouseWheel(event) {
            event.preventDefault();
            if (event.deltaY < 0) {
                camera.zoom = Math.min(MAX_ZOOM, camera.zoom + 0.1);
            } else {
                camera.zoom = Math.max(MIN_ZOOM, camera.zoom - 0.1);
            }
            camera.updateProjectionMatrix();
        }

        renderer.domElement.addEventListener('wheel', onDocumentMouseWheel, false);

        let isPinching = false;
        let initialPinchDistance = 0;
        let initialZoom = 1;

        function onTouchStart(event) {
            if (event.touches.length === 2) {
                isPinching = true;
                initialPinchDistance = getPinchDistance(event);
                initialZoom = camera.zoom;
            }
        }

        function onTouchMove(event) {
            if (isPinching && event.touches.length === 2) {
                const newPinchDistance = getPinchDistance(event);
                const zoomFactor = newPinchDistance / initialPinchDistance;
                camera.zoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, initialZoom * zoomFactor));
                camera.updateProjectionMatrix();
            }
        }

        function onTouchEnd(event) {
            if (event.touches.length < 2) {
                isPinching = false;
            }
        }

        function getPinchDistance(event) {
            const dx = event.touches[0].clientX - event.touches[1].clientX;
            const dy = event.touches[0].clientY - event.touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        renderer.domElement.addEventListener('touchstart', onTouchStart, false);
        renderer.domElement.addEventListener('touchmove', onTouchMove, false);
        renderer.domElement.addEventListener('touchend', onTouchEnd, false);
    </script>
</body>
</html>
