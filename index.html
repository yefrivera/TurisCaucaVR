<!DOCTYPE html>
<html lang="en">

<head>
    <title>TurismoCauca3.0</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="icon" href="/images/sinlimites.png" type="image/png">
    
</head>

<body>
    <div id="container"></div>
    <script type="importmap">
        {
          "imports": {
            "three": "./libs/three.module.js",
            "three/addons/": "./libs/jsm/"
          }
        }
      </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { OculusHandModel } from 'three/addons/webxr/OculusHandModel.js';
        import { createText } from 'three/addons/webxr/Text2D.js';
        import { World, System, Component, TagComponent, Types } from 'three/addons/libs/ecsy.module.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { PositionalAudioHelper } from 'three/addons/helpers/PositionalAudioHelper.js';
    
        class Object3D extends Component { }
        Object3D.schema = {
            object: { type: Types.Ref }
        };
    
        class Button extends Component { }
        Button.schema = {
            currState: { type: Types.String, default: 'resting' },
            prevState: { type: Types.String, default: 'resting' },
            pressSound: { type: Types.Ref, default: null },
            releaseSound: { type: Types.Ref, default: null },
            restingY: { type: Types.Number, default: null },
            surfaceY: { type: Types.Number, default: null },
            recoverySpeed: { type: Types.Number, default: 0.4 },
            fullPressDistance: { type: Types.Number, default: null },
            action: { type: Types.Ref, default: () => { } }
        };
    
        class ButtonSystem extends System {
            init(attributes) {
                this.renderer = attributes.renderer;
                this.soundAdded = false;
            }
    
            execute() {
                let buttonPressSound, buttonReleaseSound;
    
                if (this.renderer.xr.getSession() && !this.soundAdded) {
                    const xrCamera = this.renderer.xr.getCamera();
                    const listener = new THREE.AudioListener();
                    xrCamera.add(listener);
    
                    buttonPressSound = new THREE.Audio(listener);
                    buttonReleaseSound = new THREE.Audio(listener);
    
                    const audioLoader = new THREE.AudioLoader();
                    audioLoader.load('sounds/button-press.ogg', function (buffer) {
                        buttonPressSound.setBuffer(buffer);
                    });
                    audioLoader.load('sounds/button-release.ogg', function (buffer) {
                        buttonReleaseSound.setBuffer(buffer);
                    });
                    this.soundAdded = true;
                }
    
                this.queries.buttons.results.forEach(entity => {
                    const button = entity.getMutableComponent(Button);
                    const buttonMesh = entity.getComponent(Object3D).object;
                    if (button.restingY == null) {
                        button.restingY = buttonMesh.position.y;
                    }
                    if (buttonPressSound) {
                        button.pressSound = buttonPressSound;
                    }
                    if (buttonReleaseSound) {
                        button.releaseSound = buttonReleaseSound;
                    }
                    if (button.currState == 'fully_pressed' && button.prevState != 'fully_pressed') {
                        if (button.pressSound) button.pressSound.play();
                        button.action();
                    }
                    if (button.currState == 'recovering' && button.prevState != 'recovering') {
                        if (button.releaseSound) button.releaseSound.play();
                    }
                    button.prevState = button.currState;
                    button.currState = 'resting';
                });
            }
        }
    
        ButtonSystem.queries = {
            buttons: {
                components: [Button]
            }
        };
    
        class Pressable extends TagComponent { }
    
        class FingerInputSystem extends System {
            init(attributes) {
                this.hands = attributes.hands;
            }
    
            execute(delta) {
                this.queries.pressable.results.forEach(entity => {
                    const button = entity.getMutableComponent(Button);
                    const object = entity.getComponent(Object3D).object;
                    const pressingDistances = [];
                    this.hands.forEach(hand => {
                        if (hand && hand.intersectBoxObject(object)) {
                            const pressingPosition = hand.getPointerPosition();
                            pressingDistances.push(button.surfaceY - object.worldToLocal(pressingPosition).y);
                        }
                    });
    
                    if (pressingDistances.length == 0) {
                        if (object.position.y < button.restingY) {
                            object.position.y += button.recoverySpeed * delta;
                            button.currState = 'recovering';
                        } else {
                            object.position.y = button.restingY;
                            button.currState = 'resting';
                        }
                    } else {
                        button.currState = 'pressed';
                        const pressingDistance = Math.max(pressingDistances);
                        if (pressingDistance > 0) {
                            object.position.y -= pressingDistance;
                        }
                        if (object.position.y <= button.restingY - button.fullPressDistance) {
                            button.currState = 'fully_pressed';
                            object.position.y = button.restingY - button.fullPressDistance;
                        }
                    }
                });
            }
        }
    
        FingerInputSystem.queries = {
            pressable: {
                components: [Pressable]
            }
        };
    
        class HandsInstructionText extends TagComponent { }
        class InstructionSystem extends System {
            init(attributes) {
                this.controllers = attributes.controllers;
            }
    
            execute() {
                let visible = false;
                this.controllers.forEach(controller => {
                    if (controller.visible) {
                        visible = true;
                    }
                });
                this.queries.instructionTexts.results.forEach(entity => {
                    const object = entity.getComponent(Object3D).object;
                    if (object) {
                        object.visible = visible;
                    }
                });
            }
        }
    
        InstructionSystem.queries = {
            instructionTexts: {
                components: [HandsInstructionText]
            }
        };
    
        class OffsetFromCamera extends Component { }
        OffsetFromCamera.schema = {
            x: { type: Types.Number, default: 0 },
            y: { type: Types.Number, default: 0 },
            z: { type: Types.Number, default: 0 },
        };
    
        class NeedCalibration extends TagComponent { }
    
        class CalibrationSystem extends System {
            init(attributes) {
                this.camera = attributes.camera;
                this.renderer = attributes.renderer;
            }
    
            execute() {
                this.queries.needCalibration.results.forEach(entity => {
                    if (this.renderer.xr.getSession()) {
                        const offset = entity.getComponent(OffsetFromCamera);
                        const object = entity.getComponent(Object3D).object;
                        const xrCamera = this.renderer.xr.getCamera();
                        if (object) {
                            object.position.x = xrCamera.position.x + offset.x;
                            object.position.y = xrCamera.position.y + offset.y;
                            object.position.z = xrCamera.position.z + offset.z;
                        }
                        entity.removeComponent(NeedCalibration);
                    }
                });
            }
        }
    
        CalibrationSystem.queries = {
            needCalibration: {
                components: [NeedCalibration]
            }
        };
    
        const world = new World();
        const clock = new THREE.Clock();
        let camera, scene, renderer, sphere, loader, manager;
        let currentSceneIndex = 0;
        let selectedGroup = 0;
        
        const scenes = [
            // Popayﾃ｡n
            ['./Popayan/1.jpg', /*'./Popayan/caldas1.jpg', */'./Popayan/catedral.jpg', './Popayan/4.jpg', './Popayan/666.jpg'/*, './Popayan/7.jpg', './Popayan/gastro3.jpg'*/ ],
            // Silvia
            ['./silvia/parque.jpg', /*'./silvia/mercado2.jpg',*/ './silvia/iglesia.jpg', /*'./silvia/jardin.jpg', */'./silvia/in.jpg'],
            // Puracﾃｩ
            ['./Purace/piedra condor1.jpg', './Purace/valle frailejones.jpg', './Purace/sanjuan33.jpg'],
            // Tierradentro
            ['./Tierradentro/segovia.jpg', /*'./Tierradentro/segovia1.jpg',*/ './Tierradentro/segovia4.jpg', './Tierradentro/tablon1.jpg', './Tierradentro/museo2.jpg']
        ];
        
        const audios = [
            // Popayﾃ｡n
            ['./SoundsPopVR/1.-La-torre-del-reloj.ogg', /*'./SoundsPopVR/2.-Parque-Caldas.ogg', */'./SoundsPopVR/3.-Iglesia-la-encarnaciﾃｳn.ogg', './SoundsPopVR/5.-Puente-del-humilladero.ogg', './SoundsPopVR/7.-Morro-de-Tulcﾃ｡n.ogg'/*, './SoundsPopVR/6.-Rincﾃｳn-payanes.ogg', './SoundsPopVR/8.-Gastronomﾃｭa-de-Popayﾃ｡n.ogg'*/],
            // Silvia
            ['./SoundsSilVR/1.-Parque-de-Silvia.ogg', /*'./SoundsSilVR/2.-Mercado.ogg',*/ './SoundsSilVR/3.-Colina-de-Belen.ogg', /*'./SoundsSilVR/4.-Jardiﾌ］-botaﾌ］ico-exterior.ogg',*/ './SoundsSilVR/5.Jardiﾌ］-botaﾌ］ico-dentro-del-lugar-de-reunioﾌ］.ogg'],
            // Puracﾃｩ
            ['SoundsPurVR/1.-Piedra-del-condor.ogg', 'SoundsPurVR/2.-Valle-de-los-frailejones.ogg', 'SoundsPurVR/3.-Termales-de-san-juan.ogg'],
            // Tierradentro
            ['SoundsTieVR/Alto-de-segovia.ogg', 'SoundsTieVR/Interior-de-los-hipogeos.ogg', 'SoundsTieVR/El-tablon.ogg', 'SoundsTieVR/El-museo.ogg']
        ];

        const sceneTexts = [
            // Textos para las escenas de Popayﾃ｡n
            [
                "Torre del Reloj",
                //"Parque Caldas",
                "Iglesia La Encarnaciﾃｳn",
                "Puente del Humilladero",
                "Morro de Tulcﾃ｡n"
                //"Rincﾃｳn Payanﾃｩs",
                //"Gastronomﾃｭa de Popayﾃ｡n"
                
            ],
            // Textos para las escenas de Silvia
            [
                "Silvia, Parque Principal",
                //"Mercado tradicional",
                "Colina de Belﾃｩn",
                //"El jardﾃｭn botﾃ｡nico ",
                "El jardﾃｭn botﾃ｡nico, Casa del Pensamiento "
            ],
            // Textos para las escenas de Puracﾃｩ
            [
                "Piedra del Cﾃｳndor",
                "Valle de los Frailejones",
                "Termales de San Juan"
            ],
            // Textos para las escenas de Tierradentro
            [
                "Tierradentro, Alto de Segovia",
                //"Hipogeo 1",
                "Hipogeo 1",
                "El Tablﾃｳn, Estatuas Monolﾃｳticas",
                "Museo Arqueolﾃｳgico"
            ]
        ];
    
        let listener, positionalAudio, mixer, model, animationActions;
        let secondModel, secondMixer, secondAnimationActions;
        const textureCache = {};
        const audioCache = {};
        let homeButtonPressed = false;
        let volumeMuted = false;
    
        function makeButtonMesh(x, y, z, color) {
            const geometry = new THREE.BoxGeometry(x, y, z);
            const material = new THREE.MeshPhongMaterial({ color: color });
            const buttonMesh = new THREE.Mesh(geometry, material);
            buttonMesh.castShadow = true;
            buttonMesh.receiveShadow = true;
            return buttonMesh;
        }

        function makeButtonSphere(radius, texturePath) {
            const geometry = new THREE.SphereGeometry(radius, 32, 32); 
            const textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load(texturePath); 
            const material = new THREE.MeshBasicMaterial({ map: texture }); 
            const buttonMesh = new THREE.Mesh(geometry, material);
            buttonMesh.castShadow = true;
            buttonMesh.receiveShadow = true;
            return buttonMesh;
        }

        function createArrowMesh(width, height, color) {
            const shape = new THREE.Shape();
            shape.moveTo(0, height / 2);
            shape.lineTo(width / 2, -height / 2);
            shape.lineTo(-width / 2, -height / 2);
            shape.lineTo(0, height / 2);

            const geometry = new THREE.ShapeGeometry(shape);
            const material = new THREE.MeshPhongMaterial({ color: color });
            const arrowMesh = new THREE.Mesh(geometry, material);
            return arrowMesh;
        }

        //--------------------------------------------------------------------
    
        function init() {
            const container = document.getElementById('container');
    
            scene = new THREE.Scene();
    
            camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0.1);
            scene.add(camera);
    
            const ambientLight = new THREE.AmbientLight(0xffffff, 3);
            scene.add(ambientLight);
    
            const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);
    
            const panoSphereGeo = new THREE.SphereGeometry(500, 64, 64);
            const panoSphereMat = new THREE.MeshStandardMaterial({
                side: THREE.BackSide,
                displacementScale: -1.0,
                roughness: 1.0,
                metalness: 0.2,
            });
            sphere = new THREE.Mesh(panoSphereGeo, panoSphereMat);
    
            sphere.scale.set(-1, 1, 1);
    
            manager = new THREE.LoadingManager();
            loader = new THREE.TextureLoader(manager);
    
            loadScene(currentSceneIndex);
    
            manager.onLoad = function () {
                scene.add(sphere);
            };
    
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setAnimationLoop(animate);
            renderer.shadowMap.enabled = true;
            renderer.xr.enabled = true;
            renderer.xr.cameraAutoUpdate = false;
    
            container.appendChild(renderer.domElement);
    
            const sessionInit = {
                requiredFeatures: ['hand-tracking']
            };
    
            const vrButton = VRButton.createButton(renderer, sessionInit);
            document.body.appendChild(vrButton);
    
            renderer.xr.addEventListener('sessionstart', startSecondModelAnimation);
            renderer.xr.addEventListener('sessionend', pauseSecondModelAnimation);
    
            const controller1 = renderer.xr.getController(0);
            scene.add(controller1);
    
            const controller2 = renderer.xr.getController(1);
            scene.add(controller2);
    
            const controllerModelFactory = new XRControllerModelFactory();
    
            const controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);
    
            const hand1 = renderer.xr.getHand(0);
            const handModel1 = new OculusHandModel(hand1);
            hand1.add(handModel1);
            scene.add(hand1);
    
            const controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);
    
            const hand2 = renderer.xr.getHand(1);
            const handModel2 = new OculusHandModel(hand2);
            hand2.add(handModel2);
            scene.add(hand2);

            const buttonSpacing = 0.2; 
            const centerX = 0; 
    
            const consoleGeometry1 = new THREE.BoxGeometry(0.5, 0.12, 0.2);
            const consoleMaterial1 = new THREE.MeshPhongMaterial({ color: 0x355A64  });
            const consoleMesh1 = new THREE.Mesh(consoleGeometry1, consoleMaterial1);
            consoleMesh1.position.set(0.15, 1, -0.5);
            consoleMesh1.rotation.set(0, 0, 0);
            consoleMesh1.scale.set(1.5, 0.9, 1.5);
            consoleMesh1.castShadow = true; 
            consoleMesh1.receiveShadow = true;
            scene.add(consoleMesh1);
    
            const volumeButton = makeButtonMesh(0.12, 0.1, 0.12, 0x000000);
            const volumeButtonText = createText('沐嬉沐', 0.03);
            volumeButton.add(volumeButtonText);
            volumeButtonText.rotation.x = -Math.PI / 2;
            volumeButtonText.position.set(0, 0.051, 0);
            volumeButton.position.set(centerX - buttonSpacing / 2, 0.04, 0.01);
            consoleMesh1.add(volumeButton);
    
            const exitButton1 = makeButtonMesh(0.12, 0.1, 0.12, 0xff0000);
            const exitButtonText1 = createText('Salir', 0.03);
            exitButton1.add(exitButtonText1);
            exitButtonText1.rotation.x = -Math.PI / 2;
            exitButtonText1.position.set(0, 0.051, 0);
            exitButton1.position.set(centerX + buttonSpacing / 2, 0.04, 0.01);
            consoleMesh1.add(exitButton1);
    
            const consoleGeometry2 = new THREE.BoxGeometry(0.5, 0.12, 0.2);
            const consoleMaterial2 = new THREE.MeshPhongMaterial({ color: 0x355A64  });
            const consoleMesh2 = new THREE.Mesh(consoleGeometry2, consoleMaterial2);
            consoleMesh2.position.set(-0.35, 1, 0);
            consoleMesh2.rotation.set(0, Math.PI / 2,0 );
            consoleMesh2.scale.set(1.5, 0.9, 1.5);
            consoleMesh2.castShadow = true;
            consoleMesh2.receiveShadow = true;
            scene.add(consoleMesh2);

            // DESTINOS

            const consoleText2 = createText('Destinos', 0.05);
            consoleText2.rotation.x = -Math.PI / 2;
            consoleText2.position.set(0, 0.07, -0.05);
            consoleMesh2.add(consoleText2);

            const popayanButtonContainer = new THREE.Object3D();
            const popayanButton = makeButtonSphere(0.05, './Popayan/1.jpg');
            popayanButtonContainer.add(popayanButton);
            const popayanButtonText = createText('Popayﾃ｡n', 0.02);
            popayanButtonText.position.set(0, 0.06, 0); 
            popayanButtonContainer.add(popayanButtonText);
            popayanButtonContainer.position.set(-0.17, 0.069, 0.04);
            popayanButton.rotation.set(Math.PI/7, -Math.PI / 2, Math.PI / 2);
            consoleMesh2.add(popayanButtonContainer);
            popayanButtonText.rotation.x = -Math.PI / 2; 
                
            const silviaButtonContainer = new THREE.Object3D();
            const silviaButton = makeButtonSphere(0.05, './silvia/parque.jpg');
            silviaButtonContainer.add(silviaButton);
            const silviaButtonText = createText('Silvia', 0.02);
            silviaButtonText.position.set(0, 0.06, 0);  
            silviaButtonContainer.add(silviaButtonText);
            silviaButtonContainer.position.set(-0.055, 0.069, 0.04);
            silviaButton.rotation.set(Math.PI/9, -Math.PI / 2, Math.PI / 2);
            consoleMesh2.add(silviaButtonContainer);
            silviaButtonText.rotation.x = -Math.PI / 2;  
    
            const puraceButtonContainer = new THREE.Object3D(); 
            const puraceButton = makeButtonSphere(0.05, './Purace/san juan1.jpg');
            puraceButtonContainer.add(puraceButton);
            const puraceButtonText = createText('Puracﾃｩ', 0.02);
            puraceButtonText.position.set(0, 0.06, 0); 
            puraceButtonContainer.add(puraceButtonText);
            puraceButtonContainer.position.set(0.055, 0.069, 0.04);
            consoleMesh2.add(puraceButtonContainer);
            puraceButton.rotation.set(Math.PI/7, -Math.PI / 2, Math.PI / 2);
            puraceButtonText.rotation.x = -Math.PI / 2;
    
            const tierradentroButtonContainer = new THREE.Object3D();
            const tierradentroButton = makeButtonSphere(0.05, './Tierradentro/segovia1.jpg');
            tierradentroButtonContainer.add(tierradentroButton);
            const tierradentroButtonText = createText('Tierradentro', 0.02);
            tierradentroButtonText.position.set(0, 0.06, 0);  
            tierradentroButtonContainer.add(tierradentroButtonText);
            tierradentroButtonContainer.position.set(0.17, 0.069, 0.04);
            consoleMesh2.add(tierradentroButtonContainer);
            tierradentroButton.rotation.set(Math.PI/7, -Math.PI / 2, Math.PI / 2);
            tierradentroButtonText.rotation.x = -Math.PI / 2;

            //Tercera consola (Siguiente - Atrﾃ｡s)

            const consoleGeometry3 = new THREE.BoxGeometry(0.5, 0.12, 0.2);
            const consoleMaterial3 = new THREE.MeshPhongMaterial({ color: 0x355A64 });
            const consoleMesh3 = new THREE.Mesh(consoleGeometry3, consoleMaterial3);
            consoleMesh3.position.set(0.15, 1, 0.5);
            consoleMesh3.scale.set(1.5, 0.9, 1.5);
            consoleMesh3.rotation.set(0, Math.PI / 1, 0);
            consoleMesh3.castShadow = true;
            consoleMesh3.receiveShadow = true;
            scene.add(consoleMesh3);
    
            const nextButton = makeButtonMesh(0.12, 0.1, 0.12, 0x0288D1);
            const nextButtonText = createText('Siguiente', 0.03);
            nextButton.add(nextButtonText);
            nextButtonText.rotation.x = -Math.PI / 2;
            nextButtonText.position.set(0, 0.06, 0);
            nextButton.position.set(centerX + buttonSpacing / 2, 0.04, 0.01);
            consoleMesh3.add(nextButton);

            const nextArrow = createArrowMesh(0.1, 0.1, 0x206499);
            nextArrow.rotation.x = -Math.PI / 2; 
            nextArrow.rotation.z = -Math.PI/2;
            nextArrow.position.set(0, 0.051, 0); 
            nextButton.add(nextArrow);

    
            const backButton = makeButtonMesh(0.12, 0.1, 0.12, 0x0288D1);
            const backButtonText = createText('Atrﾃ｡s', 0.03);
            backButton.add(backButtonText);
            backButtonText.rotation.x = -Math.PI / 2;
            backButtonText.position.set(0, 0.06, 0);
            backButton.position.set(centerX - buttonSpacing / 2, 0.04, 0.01);
            consoleMesh3.add(backButton);

            const backArrow = createArrowMesh(0.1, 0.1, 0x206499);
            backArrow.rotation.x = -Math.PI / 2; 
            backArrow.rotation.z = Math.PI/2;
            backArrow.position.set(0, 0.051, 0); 
            backButton.add(backArrow);
                

            const volumeButtonAction = function () {
            if (positionalAudio.isPlaying) {
                positionalAudio.stop(); 
            }

            const audioBuffer = audioCache[`${selectedGroup}_${currentSceneIndex}`];
            
            if (audioBuffer) {
                positionalAudio.setBuffer(audioBuffer); 
                try {
                    positionalAudio.play(); 
                    startModelAnimation();

                    positionalAudio.source.onended = () => {
                        pauseModelAnimation();
                    };
                } catch (error) {
                    console.error("Error al reproducir el audio:", error);
                }
            } else {
                console.error("No se encontrﾃｳ el buffer de audio para esta escena.");
            }


            if (selectedGroup === 2) { 
                if (!videoMesh || !scene.children.includes(videoMesh)) {
                    add2DVideoToScene(); 
                } else {
                    videoElement.currentTime = 0; 
                    videoElement.play().catch(error => {
                        console.error("Error al intentar reproducir el video nuevamente:", error);
                    });
                }
            } else {
                console.log("No se agrega video en este entorno.");
            }
        };


            const exitButtonAction1 = function () {
                const exitText = createText('Saliendo de realidad virtual...', 0.04);
                exitText.position.set(0, 1.5, -0.6);
                exitText.visible = true;
                scene.add(exitText);
                setTimeout(function () {
                    pauseCurrentAudio();
                    pauseModelAnimation();
                    exitText.visible = false;
                    scene.remove(exitText);
                    renderer.xr.getSession().end();
                }, 2000);
            };

            const popayanButtonAction = function () {
                pauseCurrentAudio();
                selectedGroup = 0;
                changeEnvironmentAndPlayAudio(0);
            };

            const silviaButtonAction = function () {
                pauseCurrentAudio();
                selectedGroup = 1;
                changeEnvironmentAndPlayAudio(0);
            };

            const puraceButtonAction = function () {
                pauseCurrentAudio();
                selectedGroup = 2;
                changeEnvironmentAndPlayAudio(0);
            };

            const tierradentroButtonAction = function () {
                pauseCurrentAudio();
                selectedGroup = 3;
                changeEnvironmentAndPlayAudio(0);
            };
    
            const nextButtonAction = function () {
                pauseCurrentAudio();
                if (currentSceneIndex < scenes[selectedGroup].length - 1) {
                    currentSceneIndex++;
                } else {
                    currentSceneIndex = 0;
                }
                changeEnvironmentAndPlayAudio(currentSceneIndex);
            };
    
            const backButtonAction = function () {
                pauseCurrentAudio();
                if (currentSceneIndex > 0) {
                    currentSceneIndex--;
                } else {
                    currentSceneIndex = scenes[selectedGroup].length - 1;
                }
                changeEnvironmentAndPlayAudio(currentSceneIndex);
            };

            // Circulo en la base
            const circleRadius = 18;
            const circleSegments = 64;

            const circleGeometry = new THREE.CircleGeometry(circleRadius, circleSegments);
            const textureLoader = new THREE.TextureLoader();
            const circleTexture = textureLoader.load('./images/base.png'); 

            const circleMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff, 
                map: circleTexture, 
                transparent: true, 
                side: THREE.DoubleSide 
            });

            const circleMesh = new THREE.Mesh(circleGeometry, circleMaterial);
            circleMesh.rotation.x = -Math.PI / 2;
            circleMesh.rotation.z = Math.PI / 2;
            circleMesh.position.set(0, -20, 0);
            scene.add(circleMesh);


    
            world
                .registerComponent(Object3D)
                .registerComponent(Button)
                .registerComponent(Pressable)
                .registerComponent(HandsInstructionText)
                .registerComponent(OffsetFromCamera)
                .registerComponent(NeedCalibration)
                .registerSystem(InstructionSystem, { controllers: [controllerGrip1, controllerGrip2] })
                .registerSystem(CalibrationSystem, { renderer: renderer, camera: camera })
                .registerSystem(ButtonSystem, { renderer: renderer, camera: camera })
                .registerSystem(FingerInputSystem, { hands: [handModel1, handModel2] });

            const volumeButtonEntity = world.createEntity();
            volumeButtonEntity.addComponent(Pressable);
            volumeButtonEntity.addComponent(Object3D, { object: volumeButton });
            volumeButtonEntity.addComponent(Button, { action: volumeButtonAction, surfaceY: 0.05, fullPressDistance: 0.02 });
    
            const exitButtonEntity1 = world.createEntity();
            exitButtonEntity1.addComponent(Pressable);
            exitButtonEntity1.addComponent(Object3D, { object: exitButton1 });
            exitButtonEntity1.addComponent(Button, { action: exitButtonAction1, surfaceY: 0.05, recoverySpeed: 0.2, fullPressDistance: 0.03 });

            const popayanButtonEntity = world.createEntity();
            popayanButtonEntity.addComponent(Pressable);
            popayanButtonEntity.addComponent(Object3D, { object: popayanButton });
            popayanButtonEntity.addComponent(Button, { action: popayanButtonAction, surfaceY: 0.05, fullPressDistance: 0.02 });
    
            const silviaButtonEntity = world.createEntity();
            silviaButtonEntity.addComponent(Pressable);
            silviaButtonEntity.addComponent(Object3D, { object: silviaButton });
            silviaButtonEntity.addComponent(Button, { action: silviaButtonAction, surfaceY: 0.05, fullPressDistance: 0.02 });
    
            const puraceButtonEntity = world.createEntity();
            puraceButtonEntity.addComponent(Pressable);
            puraceButtonEntity.addComponent(Object3D, { object: puraceButton });
            puraceButtonEntity.addComponent(Button, { action: puraceButtonAction, surfaceY: 0.05, fullPressDistance: 0.02 });
    
            const tierradentroButtonEntity = world.createEntity();
            tierradentroButtonEntity.addComponent(Pressable);
            tierradentroButtonEntity.addComponent(Object3D, { object: tierradentroButton });
            tierradentroButtonEntity.addComponent(Button, { action: tierradentroButtonAction, surfaceY: 0.05, fullPressDistance: 0.02 });

            const nextButtonEntity = world.createEntity();
            nextButtonEntity.addComponent(Pressable);
            nextButtonEntity.addComponent(Object3D, { object: nextButton });
            nextButtonEntity.addComponent(Button, { action: nextButtonAction, surfaceY: 0.05, fullPressDistance: 0.02 });
    
            const backButtonEntity = world.createEntity();
            backButtonEntity.addComponent(Pressable);
            backButtonEntity.addComponent(Object3D, { object: backButton });
            backButtonEntity.addComponent(Button, { action: backButtonAction, surfaceY: 0.05, fullPressDistance: 0.02 });

            const instructionText = createText('Bienvenido al  Cauca en VR, por favor utilice sus manos para interactuar.', 0.04);
            instructionText.position.set(0, 1.5, -0.6);
            scene.add(instructionText);
    
            const instructionTextEntity = world.createEntity();
            instructionTextEntity.addComponent(HandsInstructionText);
            instructionTextEntity.addComponent(Object3D, { object: instructionText });
    
            listener = new THREE.AudioListener();
            camera.add(listener);
    
            positionalAudio = new THREE.PositionalAudio(listener);
            positionalAudio.setRefDistance(10);
            positionalAudio.setRolloffFactor(0.5);
            positionalAudio.setDirectionalCone(180, 230, 0);
            positionalAudio.position.set(-5, -2, -4);
    
            const helper = new PositionalAudioHelper(positionalAudio, 0.1);
            positionalAudio.add(helper);

            const gltfLoader = new GLTFLoader();
            gltfLoader.load('./3Dmodels/model1.glb', function (gltf) {
                model = gltf.scene;
                model.position.set(-350, -300, 100);
                model.scale.set(150, 150, 150);
                model.rotation.set(0, Math.PI / 2.5, 0);
                scene.add(model);
    
                mixer = new THREE.AnimationMixer(model);
                animationActions = {};
                gltf.animations.forEach((clip) => {
                    const action = mixer.clipAction(clip);
                    animationActions[clip.name] = action;
                    action.paused = true;
                });
            });

            gltfLoader.load('./3Dmodels/bird1.glb', function (gltf) {
                secondModel = gltf.scene;
                secondModel.position.set(200, 40, -200);
                secondModel.scale.set(8, 8, 8);
                secondModel.rotation.set(0, -Math.PI / 2, 0);
                scene.add(secondModel);
    
                secondMixer = new THREE.AnimationMixer(secondModel);
                secondAnimationActions = {};
                gltf.animations.forEach((clip) => {
                    const action = secondMixer.clipAction(clip);
                    secondAnimationActions[clip.name] = action;
                    action.paused = true;
                });
            });
    
            window.addEventListener('resize', onWindowResize);
    
            preloadAllScenes();
        }
    
        function preloadAllScenes() {
            for (let i = 0; i < scenes.length; i++) {
                for (let j = 0; j < scenes[i].length; j++) {
                    if (!textureCache[`${i}_${j}`]) {
                        loader.load(scenes[i][j], function (texture) {
                            texture.colorSpace = THREE.SRGBColorSpace;
                            texture.minFilter = THREE.NearestFilter;
                            texture.magFilter = THREE.NearestFilter;
                            texture.generateMipmaps = false;
                            textureCache[`${i}_${j}`] = texture;
                        });
                    }
                    if (!audioCache[`${i}_${j}`]) {
                        const audioLoader = new THREE.AudioLoader();
                        audioLoader.load(audios[i][j], function (buffer) {
                            audioCache[`${i}_${j}`] = buffer;
                        });
                    }
                }
            }
        }
    
        function startModelAnimation() {
            if (mixer) {
                mixer.time = 0;
                Object.values(animationActions).forEach(action => {
                    action.paused = false;
                    action.reset().play();
                });
            }
        }
    
        function pauseModelAnimation() {
            if (mixer) {
                Object.values(animationActions).forEach(action => {
                    action.paused = true;
                });
            }
        }
    
        function startSecondModelAnimation() {
            if (secondMixer) {
                secondMixer.time = 0;
                Object.values(secondAnimationActions).forEach(action => {
                    action.paused = false;
                    action.reset().play();
                });
            }
        }
    
        function pauseSecondModelAnimation() {
            if (secondMixer) {
                Object.values(secondAnimationActions).forEach(action => {
                    action.paused = true;
                });
            }
        }

        let videoElement, videoTexture, videoMesh;

        function add2DVideoToScene() {

            videoElement = document.createElement('video');
            videoElement.src = './videos/condor1.mp4';  
            videoElement.loop = false;  
            videoElement.autoplay = true;
            videoElement.crossOrigin = "anonymous";  
            videoTexture = new THREE.VideoTexture(videoElement);
            const videoMaterial = new THREE.MeshBasicMaterial({ map: videoTexture });
            const planeGeometry = new THREE.PlaneGeometry(90,66); 
            videoMesh = new THREE.Mesh(planeGeometry, videoMaterial);
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.magFilter = THREE.LinearFilter;
            videoTexture.encoding = THREE.sRGBEncoding; 
            videoMesh.position.set(-90, 7, -4); 
            videoMesh.lookAt(camera.position); 
            scene.add(videoMesh);
            videoElement.play().catch(error => {
                console.error('Error al reproducir el video:', error);
            });

            videoElement.onended = () => {
                removeVideoFromScene(); 
            };
        }
        function removeVideoFromScene() {
            if (videoMesh) {
                scene.remove(videoMesh);
                videoMesh = null;
            }
            if (videoElement) {
                videoElement.pause();
                videoElement.src = '';  
                videoElement = null;
            }
        }
    
        let currentEnvironmentText = null;

        function changeEnvironmentAndPlayAudio(sceneIndex) {
            pauseCurrentAudio();
            pauseModelAnimation();

            currentSceneIndex = sceneIndex;
            loadScene(currentSceneIndex);

            if (currentEnvironmentText) {
                scene.remove(currentEnvironmentText);
            }

            currentEnvironmentText = createText(sceneTexts[selectedGroup][currentSceneIndex], 0.05);
            currentEnvironmentText.position.set(0, 1.5, 0.6);
            currentEnvironmentText.rotation.set(0, Math.PI, 0);
            scene.add(currentEnvironmentText);

            setTimeout(() => {
                if (currentEnvironmentText) {
                    currentEnvironmentText.visible = false;
                    scene.remove(currentEnvironmentText); 
                    currentEnvironmentText = null; 
                }
            }, 10000);

            setTimeout(() => {
                if (audioCache[`${selectedGroup}_${currentSceneIndex}`]) {

                    positionalAudio.setBuffer(audioCache[`${selectedGroup}_${currentSceneIndex}`]);
                    positionalAudio.play();
                    startModelAnimation();
                    
                    positionalAudio.source.onended = () => {
                        pauseModelAnimation();
                    };
                }
            }, 5000);

            removeVideoFromScene();

                // Verifica si es la escena de "Piedra del Cﾃｳndor" (Puracﾃｩ)
            if (selectedGroup === 2 && currentSceneIndex === 0) {
                setTimeout(() => {
                    add2DVideoToScene();  // Agregar el video 5 segundos despuﾃｩs
                }, 0);
            }
            

        }
    
        function loadScene(index) {
            const cameraRotations = [
                { x: 0, y: 0, z: 0 },
                { x: 0, y: 0, z: 0 },
                { x: 0, y: 0, z: 0 },
                { x: 0, y: 0, z: 0 },
                { x: 0, y: 0, z: 0 },
                { x: 0, y: 0, z: 0 }
            ];
    
            if (index < cameraRotations.length) {
                camera.rotation.set(
                    cameraRotations[index].x,
                    cameraRotations[index].y,
                    cameraRotations[index].z
                );
            } else {
                camera.rotation.set(0, Math.PI / 2, 0);
            }
    
            if (textureCache[`${selectedGroup}_${index}`]) {
                sphere.material.map = textureCache[`${selectedGroup}_${index}`];
                sphere.material.needsUpdate = true;
            } else {
                loader.load(scenes[selectedGroup][index], function (texture) {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    texture.minFilter = THREE.NearestFilter;
                    texture.magFilter = THREE.NearestFilter;
                    texture.generateMipmaps = false;
                    textureCache[`${selectedGroup}_${index}`] = texture;
                    sphere.material.map = texture;
                    sphere.material.needsUpdate = false;
                });
            }
        }
    
        function pauseCurrentAudio() {
            if (positionalAudio.isPlaying) {
                positionalAudio.stop();
            }
        }
    
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    
        function animate() {
            const delta = clock.getDelta();
            const elapsedTime = clock.elapsedTime;
            renderer.xr.updateCamera(camera);
            world.execute(delta, elapsedTime);
            renderer.render(scene, camera);
    
            if (mixer) {
                mixer.update(delta);
            }
    
            if (secondMixer) {
                secondMixer.update(delta);
            }
        }
    
        init();
    </script>
    
</body>

</html>
